# 4.1.2 MySQL 스레딩 구조

## MySQL 스레드 모델 & 커넥션 처리 구조 요약

### 1. 포그라운드 스레드 (클라이언트 스레드)

- 클라이언트가 MySQL에 접속할 때 1:1로 생성되는 스레드
- 요청을 받아 쿼리를 실행하고 응답을 돌려줌
- 데이터를 처리할 때 → 버퍼나 캐시에 데이터가 있으면 바로 사용, 없으면 디스크에서 읽음 (InnoDB 기준)

### 2. 스레드 캐시 (Thread Cache)

- 스레드 재사용을 위한 공간
- 클라이언트 연결이 종료될 때, 스레드를 제거하지 않고 thread_cache_size만큼 보관
- 다음 연결 요청 시 스레드를 재사용
- 확인 포인트: Threads_created, Connections, 히트율

**단점:**  
너무 크면 메모리 낭비  
캐시에 남은 스레드가 잘못된 상태로 재사용되면 버그 유발 가능성

### 3. HikariCP와의 관계

- Spring에서 HikariCP를 쓰는 경우, 커넥션 풀의 최소 유휴 상태(`minimumIdle`)만큼 MySQL 클라이언트 스레드가 유지됨
- HikariCP의 minimumIdle = 10이면 → 포그라운드 스레드는 최소 10개의 연결 유지
- MySQL의 `thread_cache_size` HikariCP의 `maximumPoolSize`를 잘 조율하는것이 중요함

### 4. InnoDB vs MyISAM의 I/O 처리 차이

- InnoDB에서 포그라운드 스레드는 우선 버퍼나 캐시에서 데이터를 읽고, 거기에 없으면 디스크에서 직접 읽는다.
- MyISAM은 디스크 쓰기까지 포그라운드 스레드가 수행하지만,
-  InnoDB는 쓰기 요청을 버퍼 풀까지만 처리하고, 디스크 반영은 백그라운드 스레드가 비동기로 처리한다.

### 5. InnoDB의 쓰기 구조

```txt
[Client Write]
   ↓
Buffer Pool (Dirty Page 생성)
   ↓
Redo Log에 기록 (WAL 구조)
   ↓
[비동기]
Background Thread가
 - Redo Log를 디스크에 Flush
 - Dirty Page를 Disk에 Flush
```

- Doublewrite Buffer: 장애 시 데이터 손상을 방지하기 위한 중간 디스크 버퍼
- innodb_flush_log_at_trx_commit: 트랜잭션 커밋 시 Redo Log를 언제 flush할지 결정하는 파라미터

### 6. 백그라운드 스레드와 Checkpoint

CheckPoint란?

- Redo Log가 일정 수준 이상 쌓였을 때, Dirty Page를 디스크에 반영하고 Redo Log 공간을 재사용할 수 있게 해주는 작업.

체크포인트 관련 중요 개념:

- innodb_io_capacity: 초당 디스크에 몇 페이지를 flush할지
- innodb_max_dirty_pages_pct: Dirty Page가 이 비율 이상이면 강제 Checkpoint

# 4.1.3 메모리 할당 및 사용 구조

MySQL에서 사용되는 메모리 영역은 "글로벌 메모리 영역"과 "로컬 메모리 영역"으로 구분

## 글로벌 메모리 영역

### 메모리 할당 방식

MySQL 서버가 시작되면서 MySQL의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다.  
운영 체제의 종류마다 요청된 메모리 공간을 한번에 할당해주는 경우도 있고, 요청한 메모리 공간만큼 예약해두고 필요한만큼 조금씩 할당해주는 경우도 있다.

### 클라이언트 스레드와의 관계

일반적으로 하나의 메모리 공간만 할당되며, 클라이언트 스레드와 무관함.  
필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있으며, 생성된 글로벌 메모리 영역이 N개 이상이어도 모든 스레드에 공유됨

### 글로벌 메모리 영역의 종류

- 테이블 캐시
- InnoDB 버퍼풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

## 로컬 메모리 영역

### 클라이언트 스레드와의 관계

클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역  
클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기 때문에 "세션 메모리 영역"이라고도 표현됨  
로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되고 절대 공유되지 않는다.  

### 로컬 메모리 영역의 종류

각 쿼리의 용도별로 필요할 때(쿼리가 실행되는 순간)만 할당되고, 필요하지 않은 경우는 메모리 공간을 할당하지 않는다. (ex. 소트버퍼, 조인버퍼)  
커넥션이 열려 있는 동안 계속 할당된 상태로 남아있을 수도 있다. (ex. 커넥션버퍼, 결과버퍼)  

- 소트버퍼
- 조인버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

