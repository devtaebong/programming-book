# 4.1.2 MySQL 스레딩 구조

## MySQL 스레드 모델 & 커넥션 처리 구조 요챡

### 1. 포그라운드 스레드 (클라이언트 스레드)

- 클라이언트가 MySQL에 접속할 때 1:1로 생성되는 스레드
- 요청을 받아 쿼리를 실행하고 응답을 돌려줌
- 데이터를 처리할 때 → 버퍼나 캐시에 데이터가 있으면 바로 사용, 없으면 디스크에서 읽음

### 2. 스레드 캐시 (Thread Cache)

- 스레드 재사용을 위한 공간
- 클라이언트 연결이 종료될 때, 스레드를 제거하지 않고 thread_cache_size만큼 보관
- 다음 연결 요청 시 스레드를 재사용
- 확인 포인트: Threads_created, Connections, 히트율

**단점:**  
너무 크면 메모리 낭비  
스레드에 남은 상태가 잘못 재사용되면 버그 유발 가능성

### 3. HikariCP와의 관계

- Spring에서 HikariCP를 쓰는 경우, 커넥션 풀의 최소 유휴 상태(`minimumIdle`)만큼 MySQL 클라이언트 스레드가 유지됨
- HikariCP의 minimumIdle = 10이면 → 서버 기동 시 최소 10개의 연결 유지
- 따라서 MySQL에서는 포그라운드 스레드도 항상 10개 이상 유지됨
- MySQL의 `thread_cache_size` HikariCP의 `maximumPoolSize`를 잘 조율하는것이 중요함

### 4. InnoDB vs MyISAM의 I/O 처리 차이

- InnoDB에서 포그라운드 스레드는 우선 버퍼나 캐시에서 데이터를 읽고, 거기에 없으면 디스크에서 직접 읽는다.
- MyISAM은 디스크 쓰기까지 포그라운드 스레드가 수행하지만,
-  InnoDB는 쓰기 요청을 버퍼 풀까지만 처리하고, 디스크 반영은 백그라운드 스레드가 비동기로 처리한다.

### 5. InnoDB의 쓰기 구조

```txt
[Client Write]
   ↓
Buffer Pool (Dirty Page 생성)
   ↓
Redo Log에 기록 (WAL 구조)
   ↓
[비동기]
Background Thread가
 - Redo Log를 디스크에 Flush
 - Dirty Page를 Disk에 Flush
```

- Doublewrite Buffer: 장애 시 데이터 손상을 방지하기 위한 중간 디스크 버퍼
- innodb_flush_log_at_trx_commit: 트랜잭션 커밋 시 Redo Log를 언제 flush할지 결정하는 파라미터

### 6. 백그라운드 스레드와 Checkpoint

CheckPoint란?

- Redo Log가 일정 수준 이상 쌓였을 때, Dirty Page를 디스크에 반영하고 Redo Log 공간을 재사용할 수 있게 해주는 작업.

체크포인트 관련 중요 개념:

- innodb_io_capacity: 초당 디스크에 몇 페이지를 flush할지
- innodb_max_dirty_pages_pct: Dirty Page가 이 비율 이상이면 강제 Checkpoint

